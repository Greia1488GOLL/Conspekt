#Pascal #Никлаус_Вирт #TurboPascal #FreePascal

Pascal - процедурный язык программирования, созданный Никлаусом Виртом в 1970 году для обучения структурному программированию. 
Ключевые особенности: строгая типизация (все переменные объявляются с указанием типа), чёткая блочная структура с BEGIN/END, поддержка структурного программирования без "goto", удобная работа со структурами данных (записи, массивы, множества).
Язык компилируемый, что обеспечивает высокую производительность. Широко использовался в образовании (Turbo Pascal, Delphi), разработке ПО и научных вычислениях. Современные диалекты (Free Pascal, Delphi) сохраняют ясность синтаксиса, добавляя ООП и кроссплатформенность. Идеален для обучения основам алгоритмов и создания надёжных приложений.

Turbo Pascal - революционная среда разработки от компании Borland, выпущенная в 1983 году. Это не просто компилятор Pascal, а интегрированная среда (IDE), которая включала редактор, компилятор и отладчик в одном продукте. Его главные преимущества: невероятно быстрая компиляция (отсюда и название "Turbo"), низкая цена (всего $49,95 при том, что конкуренты стоили сотни долларов), дружественный интерфейс и отличная документация. Turbo Pascal популяризировал Pascal как язык для реальной разработки, а не только для обучения, и стал стандартом де-факто в 1980-х годах. Он работал на IBM PC и был невероятно популярен в школах, вузах и среди любителей программирования. Версия 5.5 (1989) добавила отладчик, а Turbo Pascal 7.0 (1992) стал кульминацией развития линейки, после чего Borland сосредоточился на Delphi. Turbo Pascal оставил огромное наследие - целое поколение программистов научилось кодировать именно в этой среде, а его влияние ощущается в современных IDE.


```pascal
function mergeTwoLists(l1, l2: PListNode): PListNode;
var dummy, tail: PListNode;
begin
  New(dummy);
  tail := dummy;
  while (l1 <> nil) and (l2 <> nil) do begin
    if l1^.val <= l2^.val then begin
      tail^.next := l1;
      l1 := l1^.next;
    end else begin
      tail^.next := l2;
      l2 := l2^.next;
    end;
    tail := tail^.next;
  end;
  if l1 <> nil then tail^.next := l1 else tail^.next := l2;
  mergeTwoLists := dummy^.next;
  Dispose(dummy);
end;
```
